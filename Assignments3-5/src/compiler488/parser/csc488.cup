// Date: 2017/02/01 21:56:02
// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*; // Must always import this.
import compiler488.ast.stmt.*;
import compiler488.ast.type.*;
import compiler488.ast.expn.*


import compiler488.ast.*;
import compiler488.ast.decl.*;
import compiler488.ast.expn.*;
import compiler488.ast.stmt.*;
import compiler488.ast.type.*;


/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
action code {:
:};

/* User code components 2: parser code components.
 * Modifications to the default generated parser
 */
parser code {:

    String lastError;

    /** Override the report_error method so it will display the line and
     * column of where the error occurred in the input as well as the
     * reason for the error which is passed into the method in the
     * String 'message'.
     * @param message error message to print
     * @param info symbol containing line/column numbers
     */
    public void report_error(String message, Object info)
    {
    String st = "Error";

        if (info instanceof java_cup.runtime.Symbol)
        {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

        /* s.left is supposed to hold the line number of the error.
         * s.right is supposed to hold the column number.
             * If either is < 0 the parser may have run off the end of the program
             * and a Syntax Error message without line number may be printed.
         */

            if (s.left >= 0) // Check line number.
        {
                st += " in line " + (s.left + 1);
                if (s.right >= 0) // Check column number.
                    st += ", column " + (s.right + 1);
        }
            else
               st += " at end of input ";
           }
        st += ": " + message;
        System.err.println (st);
        lastError = st;
    }

    /** Override the report_fatal_error method to use the report_error method. */
    /** @throws SyntaxErrorException */
    public void report_fatal_error (String message, Object info) throws SyntaxErrorException
    {
        report_error (message, info);
/* throw new SyntaxErrorException (lastError); */
    }

   /** version string for printing version in Main */
   public static final String version =
     " $Revision: 1.7 $ $Date: 2012/02/08 21:56:02 $Author: dw $";

:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here. Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words. These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language Winter 2011/2012

// Terminals returned by the scanner with no value attached.
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN,INTEGER,FUNCTION,PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE,THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITHX, WRITE;

// Special-character terminals, no value attached
terminal L_PAREN ,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER,LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner with a value.
terminal String IDENT;
terminal Integer INTCONST;
terminal String TEXTCONST;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal program, statement, declaration, scope;
nonterminal statements, declarations, matchedStatement, unmatchedStatement;
nonterminal variablenames, output;
nonterminal type, arguments, parameters, variable;
nonterminal expression, variablename;

nonterminal inputs, outputs, bound;
nonterminal procedureCall, parameter, conjunction, negation, compareExpn;
nonterminal arithExpn, term, factor, primary, constant;

// Non-terminals that have a value.
// nonterminal type nameList;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE; // Higher precedence.
precedence left ELSE;

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it. This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token. It ALWAYS
 * reads one more token before it will act on the production.
 */

// the main program
program ::=
    scope:scope_
    {:
        Scope scope = (Scope) scope_;
        Program prog = new Program();
        prog.setDeclarations(scope.getDeclarations());
        prog.setStatements(scope.getStatements());
        RESULT = prog;
    :}
;

scope ::=
    // scope with declarations and statements
    L_CURLEY declarations:decls_ statements:stmts_ R_CURLEY
    {:
        ASTList<Declaration> decls = (ASTList<Declaration>) decls_;
        ASTList<Stmt> stmts = (ASTList<Stmt>) stmts_;
        Scope scope = new Scope();
        scope.setDeclarations(decls);
        scope.setStatements(stmts);
        RESULT = scope;
    :}

    | L_CURLEY statements:stmts_ R_CURLEY // scope with statments only
    {:
        ASTList<Stmt> stmts = (ASTList<Stmt>) stmts_;
        Scope scope = new Scope();
        scope.setStatements(stmts);
        RESULT = scope;
    :}

    | L_CURLEY R_CURLEY // empty scope
    {: RESULT = new Scope(); :}
;

// sequence of statements
statements ::=
    statement:stmt_
    {:
        Stmt stmt = (Stmt) stmt_;
        RESULT = new ASTList<Stmt>(stmt);

        // TODO: remove once statement is implemented.
        RESULT = new ASTList<Stmt>();
    :}

    | statements:list_ statement:stmt_
    {:
        ASTList<Stmt> list = (ASTList<Stmt>) list_;
        Stmt stmt = (Stmt) stmt_;
        list.addLast(stmt);
        RESULT = list;

        // TODO: remove once statement is implemented.
        RESULT = new ASTList<Stmt>();
    :}
;

// sequence of declarations
declarations ::=
    declaration:decl_
    {:
        Declaration decl = (Declaration) decl_;
        RESULT = new ASTList<Declaration>(decl);

        // TODO: remove once declaration is implemented.
        RESULT = new ASTList<Declaration>();
    :}

    | declarations:list_ declaration:decl_
    {:
        ASTList<Declaration> list = (ASTList<Declaration>) list_;
        Declaration decl = (Declaration) decl_;
        list.addLast(decl);
        RESULT = list;

        // TODO: remove once declaration is implemented.
        RESULT = new ASTList<Declaration>();
    :}
;

matchedStatement ::=
    // assignment statement
    variable:var_ COLON EQUAL expression:e1_
    {:
        Expn var = (Expn) var_;
        Expn e1 = (Expn) e1_;

        Stmt stmt = new AssignStmt();
        stmt.setLval(var);
        stmt.setRval(e1);

        stmt.setSourceCoordinateLine(var_left);
        stmt.setSourceCoordinateLine(var_right);
        RESULT = stmt;
    :}

    // if statements
    | IF:x expression:e1_ THEN matchedStatement:s1_ ELSE matchedStatement:s2_
    {:
        Expn e1 = (Expn) e1_;
        Stmt s1 = (Stmt) s1_;
        Stmt s2 = (Stmt) s2_;

        Stmt stmt = new IfStmt();
        stmt.setCondition(e1);
        stmt.setWhenTrue(s1);
        stmt.setWhenFalse(s2);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    // while statement
    | WHILE:x expression:e1_ DO statement:s1_
    {:
        Expn e1 = (Expn) e1_;
        Stmt s1 = (Stmt) s1_;

        Stmt stmt = new WhileStmt();
        stmt.setExpn(e1);
        stmt.setBody(s1);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    // repeat statement
    | REPEAT:x statement:s1_ UNTIL expression:e1_
    {:
        Stmt s1 = (Stmt) s1_;
        Expn e1 = (Expn) e1_;

        Stmt stmt = new RepeatUntilStmt();
        stmt.setExpn(e1);
        stmt.setBody(s1);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    // exit statements
    | EXIT:x
    {:
        ExitStmt stmt = new ExitStmt();
        stmt.setLevel(1);
        stmt.setExpn(null);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    | EXIT:x INTCONST:i
    {:
        ExitStmt stmt = new ExitStmt();
        stmt.setLevel(i);
        stmt.setExpn(null);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    | EXIT:x WHEN expression:e1_
    {:
        Expn e1 = (Expn) e1_;

        ExitStmt stmt = new ExitStmt();
        stmt.setLevel(1);
        stmt.setExpn(e1);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    | EXIT:x INTCONST:i WHEN expression:e1_
    {:
        Expn e1 = (Expn) e1_;

        ExitStmt stmt = new ExitStmt();
        stmt.setLevel(i);
        stmt.setExpn(e1);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    | RETURN:x WITHX expression:e1_
    {:
        Expn e1 = (Expn) e1_;

        ReturnStmt stmt = new ReturnStmt();
        stmt.setValue(e1);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    // return statements
    | RETURN:x
    {:
        ReturnStmt stmt = new ReturnStmt();
        stmt.setValue(null);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    // input/output statments
    | WRITE:x outputs:outputs_
    {:
        ASTList<Printable> outputs = (ASTList<Printable>) outputs_;

        WriteStmt stmt = new WriteStmt();
        stmt.setOutputs(outputs);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    | READ:x inputs:inputs_
    {:
        ASTList<Readable> outputs = (ASTList<Readable>) outputs_;

        ReadStmt stmt = new ReadStmt();
        stmt.setInputs(inputs);

        stmt.setSourceCoordinateLine(xleft);
        stmt.setSourceCoordinateColumn(xright);
        RESULT = stmt;
    :}

    // procedure call
    | procedureCall:stmt_
    {:
        RESULT = stmt_;
    :}

    | scope // embedded scope
    {: RESULT = null; :}
;

unmatchedStatement ::=
    IF expression THEN statement
    {: RESULT = null; :}

    | IF expression THEN matchedStatement ELSE unmatchedStatement
    {: RESULT = null; :}
;

procedureCall ::=
    IDENT // call procedure with no parameters
    {: RESULT = null; :}

    | IDENT L_PAREN arguments R_PAREN // call procedure with parameters
    {: RESULT = null; :}
;

declaration ::=
    VAR variablenames:varnames COLON type:type_ // declare scalar/array variables
    {:
	    MultiDeclarations multiDecl = new MultiDeclarations();
	    ASTList<DeclarationPart> vars = (ASTList<DeclarationPart>) varnames;
	    multiDecl.setElements(vars);
	    Type type = (Type) type_;
	    multiDecl.setType(type);
    	RESULT = multiDecl;
    :}

    | FUNCTION IDENT:ident COLON type:type_ scope:scope_ // declare function
    {:
    	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	routineDeclaration.setType((Type) type_);
    	RESULT = routineDeclaration;
     :}

    | FUNCTION IDENT:ident L_PAREN parameters:params R_PAREN COLON type:type_ scope:scope_
    {:
    	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	routineBody.setParameters((ASTList<ScalarDecl>) params);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	routineDeclaration.setType((Type) type_);
    	RESULT = routineDeclaration;

    :}

    | PROCEDURE IDENT:ident scope:scope_ // declare procedure
    {:
     	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	RESULT = routineDeclaration;
     :}

    | PROCEDURE IDENT:ident L_PAREN parameters:params R_PAREN scope:scope_
    {:
    	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	routineBody.setParameters((ASTList<ScalarDecl>) params);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	RESULT = routineDeclaration;
	:}
;

// list of variables being declared
variablenames ::=
    variablename:variablename
    {:
    	ASTList<DeclarationPart> vars = new ASTList();
	    vars.addLast((DeclarationPart) variablename);
    	RESULT = vars;
    :}

    | variablenames:variablenames COMMA variablename:variablename
    {:
        ASTList<DeclarationPart> vars = (ASTList<DeclarationPart>) variablenames;
	    vars.addLast((DeclarationPart) variablename);
    	RESULT = vars;
    :}
;

variablename ::=
    IDENT // scalar variable
    {: RESULT = null; :}

    | IDENT L_SQUARE INTCONST R_SQUARE // array variable with upper bound
    {: RESULT = null; :}

    | IDENT L_SQUARE bound DOT DOT bound R_SQUARE // array variable with upper/lower bounds
    {: RESULT = null; :}
;

bound ::=
    INTCONST // positive array bound
    {: RESULT = null; :}

    | MINUS INTCONST// negative array bound
    {: RESULT = null; :}
;

type ::=
    INTEGER // integer type
    {: RESULT = null; :}

    | BOOLEAN // boolean type
    {: RESULT = null; :}
;

// list of output expressions
outputs ::=
    output:e1_
    {:
        Expn e1 = (Expn) e1_;

        ASTList<Expn> list = new ASTList<Expn>(e1);

        list.setSourceCoordinateLine(e1_left);
        list.setSourceCoordinateColumn(e1_right);
    	RESULT = list;
    :}

    | outputs:list_ COMMA output:e1_
    {:
        ASTList<Expn> list = (ASTList<Expn>) list_;
        Expn e1 = (Expn) e1_;

    	list.addLast(e1);
    	RESULT = list;
    :}
;

output ::=
    // integer expression
    expression:e1_
    {:
        RESULT = e1_;
    :}

    // text constant
    | TEXTCONST:s
    {:
        TextConstExpn e = new TextConstExpn();
        e.setValue(s);

        e.setSourceCoordinateLine(sleft);
        e.setSourceCoordinateColumn(sright);
        RESULT = e;
    :}

    // newline constant
    | NEWLINE:x
    {:
        SkipConstExpn e = new SkipConstExpn();

        e.setSourceCoordinateLine(xleft);
        e.setSourceCoordinateColumn(xright);
        RESULT = e;
    :}
;

// list of variables being read into
inputs ::=
    variable:var_
    {:
        Readable var = (Readable) var_;

    	ASTList<Readable> list = new ASTList<Readable>(var);

        list.setSourceCoordinateLine(var_left);
        list.setSourceCoordinateColumn(var_right);
    	RESULT = list;
    :}

    | inputs:list_ COMMA variable:var_
    {:
        ASTList<Readable> list = (ASTList<Readable>) list_;
        Readable var = (Readable) var_;

    	list.addLast(var);
    	RESULT = list;
    :}
;

// list of function/procedure arguments
arguments ::=
    expression:e1_
    {:
        Expn e1 = (Expn) e1_;

    	ASTList<Expn> list = new ASTList<Expn>(e1);

        list.setSourceCoordinateLine(e1_left);
        list.setSourceCoordinateColumn(e1_right);
    	RESULT = list;
    :}

    | arguments:list_ COMMA expression:e1_
    {:
        ASTList<Expn> list = (ASTList<Expn>) list_;
        Expn e1 = (Expn) e1_;

    	list.addLast(e1);
    	RESULT = list;
    :}
;

// list of function/procedure formal parameters
parameters ::=
    parameter:param
    {:
     	ASTList<ScalarDecl> scalarDeclarations = new ASTList<ScalarDecl>((ScalarDecl) param);
    	RESULT = scalarDeclarations;
    :}

    | parameters:params COMMA parameter:param
    {:
    	ASTList<ScalarDecl> scalarDeclarations = (ASTList<ScalarDecl>) params;
    	scalarDeclarations.addLast((ScalarDecl) param);
    	RESULT = scalarDeclarations;
    :}
;

// declare one parameter
parameter ::=
    IDENT:ident COLON type:type_
    {:
	    ScalarDecl sd = new ScalarDecl();
	    sd.setName(ident);
	    sd.setType((Type) type_);
	    RESULT = sd;
    :}
;

// disjunctions, associate left-to-right
expression ::=
    conjunction
    {: RESULT = null; :}

    | expression OR conjunction
    {: RESULT = null; :}
;

// conjunctions, associate left-to-right
conjunction ::=
    negation
    {: RESULT = null; :}

    | conjunction AND negation
    {: RESULT = null; :}
;

// negations
negation ::=
    compareExpn:exp1_
    {:
        RESULT = exp1_;
    :}

    | NOT negation:exp1
    {:
        Expn exp1 = (Expn) exp1_;

    	NotExpn e = new NotExpn();
    	e.setOpSymbol("not");
    	e.setOperand(exp1);
    	RESULT = e;
    :}
;

// comparisons, do not associate
compareExpn ::=
    arithExpn:exp1_
    {:
        RESULT = exp1_;
    :}

    | arithExpn:exp1_ EQUAL arithExpn:exp2_
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

    	EqualsExpn equalsExpn = new EqualsExpn();
    	equalsExpn.setOpSymbol("=");
    	equalsExpn.setLeft(exp1);
    	equalsExpn.setRight(exp2);
     	RESULT = equalsExpn;
    :}

    | arithExpn:exp1_ NOT EQUAL arithExpn:exp2_
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

    	EqualsExpn equalsExpn = new EqualsExpn();
    	equalsExpn.setOpSymbol("=");
    	equalsExpn.setLeft(exp1);
    	equalsExpn.setRight(exp2);

    	NotExpn notExpn = new NotExpn();
    	notExpn.setOpSymbol("not");
    	notExpn.setOperand(equalsExpn);
     	RESULT = notExpn;
    :}

    | arithExpn:exp1 LESS arithExpn:exp2
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

        CompareExpn compExpn = new CompareExpn();
    	compExpn.setOpSymbol("<");
    	compExpn.setLeft(exp1);
    	compExpn.setRight(exp2);
   		RESULT = compExpn;
    :}

    | arithExpn:exp1 LESS EQUAL arithExpn:exp2
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

        CompareExpn compExpn = new CompareExpn();
    	compExpn.setOpSymbol("<=");
    	compExpn.setLeft(exp1);
    	compExpn.setRight(exp2);
   		RESULT = compExpn;
    :}

    | arithExpn:exp1 GREATER arithExpn:exp2
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

        CompareExpn compExpn = new CompareExpn();
    	compExpn.setOpSymbol(">");
    	compExpn.setLeft(exp1);
    	compExpn.setRight(exp2);
   		RESULT = compExpn;
    :}

    | arithExpn:exp1 GREATER EQUAL arithExpn:exp2
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

        CompareExpn compExpn = new CompareExpn();
    	compExpn.setOpSymbol(">=");
    	compExpn.setLeft(exp1);
    	compExpn.setRight(exp2);
   		RESULT = compExpn;
    :}
;

// expressions, associate + , - left-to-right
arithExpn ::=
    term:exp1_
    {:
        RESULT = exp1_;
    :}

    | arithExpn:exp1 PLUS term:exp2
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

    	ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setOpSymbol("+");
    	arithExpn.setLeft(exp1);
    	arithExpn.setRight(exp2);
    	RESULT = arithExpn;
    :}

    | arithExpn:exp1 MINUS term:exp2
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

        ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setOpSymbol("-");
    	arithExpn.setLeft(exp1);
    	arithExpn.setRight(exp2);
    	RESULT = arithExpn;
    :}
;

// terms, associate * , / left-to-right
term ::=
    factor:exp1_
    {:
    	RESULT = exp1_;
    :}

    | term:exp1_ TIMES factor:exp2_
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

    	ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setOpSymbol("*");
    	arithExpn.setLeft(exp1);
    	arithExpn.setRight(exp2);
    	RESULT = arithExpn;
    :}

    | term:exp1_ DIVIDE factor:exp2_
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;

    	ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setOpSymbol("/");
    	arithExpn.setLeft(exp1);
    	arithExpn.setRight(exp2);
    	RESULT = arithExpn;
    :}
;

// unary minus
factor ::=
    primary:exp1_
    {:
        RESULT = exp1_;
    :}

    | MINUS factor:exp1_
    {:
        Expn exp1 = (Expn) exp1_;

    	UnaryMinusExpn e = new UnaryMinusExpn();
    	e.setOpSymbol("-");
    	e.setOperand(exp1);
	    RESULT = e;
	:}
;

primary ::=
    // integer or boolean constant
    constant:exp1_
    {:
        RESULT = exp1_;
    :}

    // scalar, array variable or function call
    | variable:exp1_
    {:
        RESULT = exp1_;
    :}

    | IDENT:ident_ L_PAREN arguments:arguments R_PAREN // function call
    {:
        ASTList<Expn> args = (ASTList<Expn>) args_;

    	FunctionCallExpn fncall = new FunctionCallExpn();
    	fncall.setIdent(ident);
    	fncall.setArguments(args);
    	RESULT = fncall;

     :}

    // parenthesized expression
    | L_PAREN expression:exp1_ R_PAREN
    {:
        RESULT = exp1_;
    :}

    | L_PAREN expression:exp1 QUESTION expression:exp2 COLON expression:exp3 R_PAREN
    {:
        Expn exp1 = (Expn) exp1_;
        Expn exp2 = (Expn) exp2_;
        Expn exp3 = (Expn) exp3_;

    	ConditionalExpn condExpn = new ConditionalExpn();
    	condExpn.setCondition(exp1);
    	condExpn.setTrueValue(exp2);
    	condExpn.setFalseValue(exp3);
    	RESULT = condExpn;
    :}
;

constant ::=
    INTCONST:intconst_ // integer constant
    {:
    	IntConstExpn intconst = new IntConstExpn();
    	intconst.setValue(intconst_);
    	RESULT = intconst;
    :}

    | TRUE // constant true
    {:
    	BoolConstExpn bce = new BoolConstExpn();
    	bce.setValue(true);
    	RESULT = bce;
    :}

    | FALSE // constant false
    {:
    	BoolConstExpn bce = new BoolConstExpn();
    	bce.setValue(false);
    	RESULT = bce;
    :}
;

variable ::=
    IDENT:id // scalar variable or function call
    {:
	    IdentExpn e = new IdentExpn();
	    e.setIdent(id);
	    RESULT = e;
	:}

    | IDENT:id L_SQUARE expression:exp1 R_SQUARE // element of an array
    {:
        Expn exp1 = (Expn) exp1_;

	    SubsExpn e = new SubsExpn();
	    e.setVariable(id);
	    e.setOpSymbol(id);
	    e.setOperand(exp1);
	    RESULT = e;
    :}
;
