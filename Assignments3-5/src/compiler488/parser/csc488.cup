// Date: 2017/02/01 21:56:02
// Package and import specifications section.

package compiler488.parser;

import java_cup.runtime.*; // Must always import this.
import compiler488.ast.stmt.*;
import compiler488.ast.type.*;
import compiler488.ast.expn.*


import compiler488.ast.*;
import compiler488.ast.decl.*;
import compiler488.ast.expn.*;
import compiler488.ast.stmt.*;
import compiler488.ast.type.*;


/* User code components 1: action code components.
 * Code to be used inside the actions triggered when productions are matched.
 * If any common code is needed for more than one action , put it here.
 */
action code {:
:};

/* User code components 2: parser code components.
 * Modifications to the default generated parser
 */
parser code {:

    String lastError;

    /** Override the report_error method so it will display the line and
     * column of where the error occurred in the input as well as the
     * reason for the error which is passed into the method in the
     * String 'message'.
     * @param message error message to print
     * @param info symbol containing line/column numbers
     */
    public void report_error(String message, Object info)
    {
    String st = "Error";

        if (info instanceof java_cup.runtime.Symbol)
        {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

        /* s.left is supposed to hold the line number of the error.
         * s.right is supposed to hold the column number.
             * If either is < 0 the parser may have run off the end of the program
             * and a Syntax Error message without line number may be printed.
         */

            if (s.left >= 0) // Check line number.
        {
                st += " in line " + (s.left + 1);
                if (s.right >= 0) // Check column number.
                    st += ", column " + (s.right + 1);
        }
            else
               st += " at end of input ";
           }
        st += ": " + message;
        System.err.println (st);
        lastError = st;
    }

    /** Override the report_fatal_error method to use the report_error method. */
    /** @throws SyntaxErrorException */
    public void report_fatal_error (String message, Object info) throws SyntaxErrorException
    {
        report_error (message, info);
/* throw new SyntaxErrorException (lastError); */
    }

   /** version string for printing version in Main */
   public static final String version =
     " $Revision: 1.7 $ $Date: 2012/02/08 21:56:02 $Author: dw $";

:};

/* User code components 3: initialization code.
 * If you want some code to be executed before the parser asks for the first
 * token, add it here.
 */
init with {:
:};

/* User code components 4: scanner specification code.
 * If you need to override the way the parser asks the scanner for the
 * next token, put your preferred method here. Uncomment the line following
 * this comment, replace the line after that with your code, and uncomment
 * the line after that.
 */
// scan with {:
// your code goes here
// :};

/* Symbol lists section.
 * The names of terminals and non-terminals are not allowed to be CUP
 * reserved words. These include "code", "action", "parser", "terminal",
 * "non", "nonterminal", "init", "scan", "with", "start", "precedence",
 * "left", "right", "nonassoc", "import", and "package".
 */

// DEFINITIONS for CSC488S Source Language Winter 2011/2012

// Terminals returned by the scanner with no value attached.
terminal AND, OR, NOT, TRUE, FALSE;
terminal BOOLEAN,INTEGER,FUNCTION,PROCEDURE;
terminal DO, ELSE, EXIT, IF;
terminal READ, REPEAT, RETURN, NEWLINE,THEN, UNTIL;
terminal VAR, WHEN, WHILE, WITHX, WRITE;

// Special-character terminals, no value attached
terminal L_PAREN ,R_PAREN,L_SQUARE, R_SQUARE, L_CURLEY, R_CURLEY;
terminal EQUAL, GREATER,LESS, COMMA, DOT, QUESTION, COLON;
terminal PLUS, MINUS, TIMES, DIVIDE;

// Terminals returned by the scanner with a value.
terminal String IDENT;
terminal Integer INTCONST;
terminal String TEXTCONST;

// Non-terminals that have no value.
// nonterminal xxx

nonterminal program, statement, declaration, scope;
nonterminal statements, declarations, matchedStatement, unmatchedStatement;
nonterminal variablenames, output;
nonterminal type, arguments, parameters, variable;
nonterminal expression, variablename;

nonterminal inputs, outputs, bound;
nonterminal procedureCall, parameter, conjunction, negation, compareExpn;
nonterminal arithExpn, term, factor, primary, constant;

// Non-terminals that have a value.
// nonterminal type nameList;

// PLEASE NOTE: your grammar can not use the 'precedence'
// feature of java-cup. The lines below should remain
// commented.
//
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE; // Higher precedence.
precedence left ELSE;

// The grammar section.

// This specifies the initial symbol of the grammar.
start with program;

/* Notice that sometimes the action must be inside the production rule,
 * not after it. This is a subtle yet significant difference from YACC.
 * This is because the CUP parser is looking ahead one token. It ALWAYS
 * reads one more token before it will act on the production.
 */

// the main program
program ::=
    scope:scope_
    {:
        Scope scope = (Scope) scope_;
        Program prog = new Program();
        prog.setDeclarations(scope.getDeclarations());
        prog.setStatements(scope.getStatements());
        RESULT = prog;
    :}
;

scope ::=
    // scope with declarations and statements
    L_CURLEY declarations:decls_ statements:stmts_ R_CURLEY
    {:
        ASTList<Declaration> decls = (ASTList<Declaration>) decls_;
        ASTList<Stmt> stmts = (ASTList<Stmt>) stmts_;
        Scope scope = new Scope();
        scope.setDeclarations(decls);
        scope.setStatements(stmts);
        RESULT = scope;
    :}

    | L_CURLEY statements:stmts_ R_CURLEY // scope with statments only
    {:
        ASTList<Stmt> stmts = (ASTList<Stmt>) stmts_;
        Scope scope = new Scope();
        scope.setStatements(stmts);
        RESULT = scope;
    :}

    | L_CURLEY R_CURLEY // empty scope
    {: RESULT = new Scope(); :}
;

// sequence of statements
statements ::=
    statement:stmt_
    {:
        Stmt stmt = (Stmt) stmt_;
        RESULT = new ASTList<Stmt>(stmt);

        // TODO: remove once statement is implemented.
        RESULT = new ASTList<Stmt>();
    :}

    | statements:list_ statement:stmt_
    {:
        ASTList<Stmt> list = (ASTList<Stmt>) list_;
        Stmt stmt = (Stmt) stmt_;
        list.addLast(stmt);
        RESULT = list;

        // TODO: remove once statement is implemented.
        RESULT = new ASTList<Stmt>();
    :}
;

// sequence of declarations
declarations ::=
    declaration:decl_
    {:
        Declaration decl = (Declaration) decl_;
        RESULT = new ASTList<Declaration>(decl);

        // TODO: remove once declaration is implemented.
        RESULT = new ASTList<Declaration>();
    :}

    | declarations:list_ declaration:decl_
    {:
        ASTList<Declaration> list = (ASTList<Declaration>) list_;
        Declaration decl = (Declaration) decl_;
        list.addLast(decl);
        RESULT = list;

        // TODO: remove once declaration is implemented.
        RESULT = new ASTList<Declaration>();
    :}
;

statement ::=
    matchedStatement
    {: RESULT = null; :}

    | unmatchedStatement
    {: RESULT = null; :}
;

matchedStatement ::=
    variable COLON EQUAL expression // assignment statement
    {: RESULT = null; :}

    | IF expression THEN matchedStatement ELSE matchedStatement // if statements
    {: RESULT = null; :}

    | WHILE expression DO statement // while statement
    {: RESULT = null; :}

    | REPEAT statement UNTIL expression // repeat statement
    {: RESULT = null; :}

    | EXIT // exit statements
    {: RESULT = null; :}

    | EXIT INTCONST
    {: RESULT = null; :}

    | EXIT WHEN expression
    {: RESULT = null; :}

    | EXIT INTCONST WHEN expression
    {: RESULT = null; :}

    | RETURN WITHX expression
    {: RESULT = null; :}

    | RETURN // return statements
    {: RESULT = null; :}

    | WRITE outputs // input/output statments
    {: RESULT = null; :}

    | READ inputs
    {: RESULT = null; :}

    | procedureCall // procedure call
    {: RESULT = null; :}

    | scope // embedded scope
    {: RESULT = null; :}
;

unmatchedStatement ::=
    IF expression THEN statement
    {: RESULT = null; :}

    | IF expression THEN matchedStatement ELSE unmatchedStatement
    {: RESULT = null; :}
;

procedureCall ::=
    IDENT // call procedure with no parameters
    {: RESULT = null; :}

    | IDENT L_PAREN arguments R_PAREN // call procedure with parameters
    {: RESULT = null; :}
;

declaration ::=
    VAR variablenames:varnames COLON type:type_ // declare scalar/array variables
    {:
	    MultiDeclarations multiDecl = new MultiDeclarations();
	    ASTList<DeclarationPart> vars = (ASTList<DeclarationPart>) varnames;
	    multiDecl.setElements(vars);
	    Type type = (Type) type_;
	    multiDecl.setType(type);
    	RESULT = multiDecl;
    :}

    | FUNCTION IDENT:ident COLON type:type_ scope:scope_ // declare function
    {:
    	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	routineDeclaration.setType((Type) type_);
    	RESULT = routineDeclaration;
     :}

    | FUNCTION IDENT:ident L_PAREN parameters:params R_PAREN COLON type:type_ scope:scope_
    {:
    	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	routineBody.setParameters((ASTList<ScalarDecl>) params);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	routineDeclaration.setType((Type) type_);
    	RESULT = routineDeclaration;

    :}

    | PROCEDURE IDENT:ident scope:scope_ // declare procedure
    {:
     	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	RESULT = routineDeclaration;
     :}

    | PROCEDURE IDENT:ident L_PAREN parameters:params R_PAREN scope:scope_
    {:
    	Scope scope = (Scope) scope_;
    	RoutineBody routineBody = new RoutineBody();
    	routineBody.setBody(scope);
    	routineBody.setParameters((ASTList<ScalarDecl>) params);
    	RoutineDecl routineDeclaration = new RoutineDecl();
    	routineDeclaration.setName(ident);
    	RESULT = routineDeclaration;
	:}
;

// list of variables being declared
variablenames ::=
    variablename:variablename
    {:
    	ASTList<DeclarationPart> vars = new ASTList();
	    vars.addLast((DeclarationPart) variablename);
    	RESULT = vars;
    :}

    | variablenames:variablenames COMMA variablename:variablename
    {:
        ASTList<DeclarationPart> vars = (ASTList<DeclarationPart>) variablenames;
	    vars.addLast((DeclarationPart) variablename);
    	RESULT = vars;
    :}
;

variablename ::=
    IDENT // scalar variable
    {: RESULT = null; :}

    | IDENT L_SQUARE INTCONST R_SQUARE // array variable with upper bound
    {: RESULT = null; :}

    | IDENT L_SQUARE bound DOT DOT bound R_SQUARE // array variable with upper/lower bounds
    {: RESULT = null; :}
;

bound ::=
    INTCONST // positive array bound
    {: RESULT = null; :}

    | MINUS INTCONST// negative array bound
    {: RESULT = null; :}
;

type ::=
    INTEGER // integer type
    {: RESULT = null; :}

    | BOOLEAN // boolean type
    {: RESULT = null; :}
;

// list of output expressions
outputs ::=
    output
    {: RESULT = null; :}

    | outputs COMMA output
    {: RESULT = null; :}
;

output ::=
    expression // integer expression
    {: RESULT = null; :}

    | TEXTCONST // text constant
    {: RESULT = null; :}

    | NEWLINE // newline constant
    {: RESULT = null; :}
;

// list of variables being read into
inputs ::=
    variable
    {: RESULT = null; :}

    | inputs COMMA variable
    {: RESULT = null; :}
;

// list of function/procedure arguments
arguments ::=
    expression
    {: RESULT = null; :}

    | arguments COMMA expression
    {: RESULT = null; :}
;

// list of function/procedure formal parameters
parameters ::=
    parameter:param
    {:
     	ASTList<ScalarDecl> scalarDeclarations = new ASTList<ScalarDecl>((ScalarDecl) param);
    	RESULT = scalarDeclarations;
    :}

    | parameters:params COMMA parameter:param
    {:
    	ASTList<ScalarDecl> scalarDeclarations = (ASTList<ScalarDecl>) params;
    	scalarDeclarations.addLast((ScalarDecl) param);
    	RESULT = scalarDeclarations;
    :}
;

// declare one parameter
parameter ::=
    IDENT:ident COLON type:type_
    {:
	    ScalarDecl sd = new ScalarDecl();
	    sd.setName(ident);
	    sd.setType((Type) type_);
	    RESULT = sd;
    :}
;

// disjunctions, associate left-to-right
expression ::=
    conjunction
    {: RESULT = null; :}

    | expression OR conjunction
    {: RESULT = null; :}
;

// conjunctions, associate left-to-right
conjunction ::=
    negation
    {: RESULT = null; :}

    | conjunction AND negation
    {: RESULT = null; :}
;

// negations
negation ::=
    compareExpn:compareExpn
    {: RESULT = compareExpn; :}

    | NOT negation:exp1
    {:
    	NotExpn notExpn = new NotExpn();
    	notExpn.setOperand((ArithExpn) notExpn);
    	notExpn.setOpSymbol("not");
    	RESULT = notExpn;
    :}
;

// comparisons, do not associate
compareExpn ::=
    arithExpn:arithExpn
    {: RESULT = arithExpn; :}

    | arithExpn:exp1 EQUAL arithExpn:exp1 // TODO:FIX this stuff please.
    {:
    	EqualsExpn equalExpn = new EqualsExpn();
    	equalExpn.setLeft((ArithExpn) exp1);
    	equalExpn.setRight((ArithExpn) exp2);
    	equalExpn.setOpSymbol("=");
     	RESULT = equalExpn;
      :}

    | arithExpn:exp1 NOT EQUAL arithExpn:exp2
    {:
    	NotExpn notExp = new NotExpn();
    	EqualsExpn equalExpn = new EqualsExpn();
    	equalExpn.setLeft((ArithExpn) exp1);
    	equalExpn.setRight((ArithExpn) exp2);
    	equalExpn.setOpSymbol("=");
    	notExp.setOperand(equalExpn);
    	notExp.setOpSymbol("not");
     	RESULT = notExp;
    :}

    | arithExpn:exp1 LESS arithExpn:exp2
    {:
        CompareExpn compExpn = new CompareExpn();
    	compExpn.setLeft((ArithExpn) exp1);
    	compExpn.setRight((ArithExpn) exp2);
    	compExpn.setOpSymbol("<");
   		RESULT = compExpn;
    :}

    | arithExpn:exp1 LESS EQUAL arithExpn:exp2
    {:
        CompareExpn compExpn = new CompareExpn();
    	compExpn.setLeft((ArithExpn) exp1);
    	compExpn.setRight((ArithExpn) exp2);
    	compExpn.setOpSymbol("<=");
   		RESULT = compExpn;
    :}

    | arithExpn:exp1 GREATER arithExpn:exp2
    {:
        CompareExpn compExpn = new CompareExpn();
    	compExpn.setLeft((ArithExpn) exp1);
    	compExpn.setRight((ArithExpn) exp2);
    	compExpn.setOpSymbol(">");
   		RESULT = compExpn;
    :}

    | arithExpn:exp1 GREATER EQUAL arithExpn:exp2
    {:
        CompareExpn compExpn = new CompareExpn();
    	compExpn.setLeft((ArithExpn) exp1);
    	compExpn.setRight((ArithExpn) exp2);
    	compExpn.setOpSymbol(">=");
   		RESULT = compExpn;
    :}
;

// expressions, associate + , - left-to-right
arithExpn ::=
    term:term
    {: RESULT = term; :}

    | arithExpn:exp1 PLUS term:exp2
    {:
    	ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setLeft(exp1);
    	arithExpn.setRight(exp2);
    	arithExpn.setOpSymbol("+");
    	RESULT = arithExpn;
    :}

    | arithExpn:exp1 MINUS term:exp2
    {:
        ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setLeft(exp1);
    	arithExpn.setRight(exp2);
    	arithExpn.setOpSymbol("-");
    	RESULT = arithExpn;
    :}
;

// terms, associate * , / left-to-right
term ::=
    factor
    {:
    	RESULT = factor;
    :}

    | term:term TIMES factor:factor
    {:
    	ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setLeft(term);
    	arithExpn.setRight(factor);
    	arithExpn.setOpSymbol("*");
    	RESULT = arithExpn;
    :}

    | term:term DIVIDE factor:factor
    {:
    	ArithExpn arithExpn = new ArithExpn();
    	arithExpn.setLeft(term);
    	arithExpn.setRight(factor);
    	arithExpn.setOpSymbol("/");
    	RESULT = arithExpn;
    :}
;

// unary minus
factor ::=
    primary
    {: RESULT = primary; :}

    | MINUS factor
    {:
    	UnaryMinusExpn minus = new UnaryMinusExpn();
    	minus.setOperand((Expn) factor);
    	minus.SetOpSymbol("-");
	    RESULT = minus;
	:}
;

primary ::=
    constant:constant // integer or boolean constant
    {: RESULT = constant; :}

    | variable:variable // scalar, array variable or function call
    {: RESULT = variable; :}

    | IDENT:ident_ L_PAREN arguments:arguments R_PAREN // function call
    {:
    	FunctionCallExpn fncall = new FunctionCallExpn();
    	fncall.setArguments((ASTList<Expn>) arguments);
    	fncall.setIdent(ident_);
    	RESULT = fncall;

     :}

    | L_PAREN expression:expression R_PAREN // parenthesized expression
    {: RESULT = expression; :}

    | L_PAREN expression:exp1 QUESTION expression:exp2 COLON expression:exp3 R_PAREN
    {:
    	ConditionalExpn condExpn = new ConditionalExpn();
    	condExpn.setCondition(exp1);
    	condExpn.setTrueValue(exp2);
    	condExpn.setFalseValue(exp3);
    	RESULT = condExpn;
    :}
;

constant ::=
    INTCONST:intconst_ // integer constant
    {:
    	IntConstExpn intconst = new IntConstExpn();
    	intconst.setValue(intconst_);
    	RESULT = intconst;
    :}

    | TRUE // constant true
    {:
    	BoolConstExpn boolconst = new BoolConstExpn();
    	boolconst.setValue(true);
    	RESULT = boolconst;
    :}

    | FALSE // constant false
    {:
    	BoolConstExpn boolconst = new BoolConstExpn();
    	boolconst.setValue(false);
    	RESULT = boolconst;
    :}
;

variable ::=
    IDENT:id // scalar variable or function call
    {:
	    IdentExpn identifier = new IdentExpn();
	    identifier.setIdent(id);
	    RESULT = identifier;
	:}

    | IDENT:id L_SQUARE expression:exp1 R_SQUARE // element of an array
    {:
	    SubsExpn subexpn = new SubsExpn();
	    subexpn.setVariable(id);
	    subexpn.setOperand((Expn) exp1);
	    subexpn.setOpSymbol("Subscript");
	    RESULT = subexpn;
    :}
;
